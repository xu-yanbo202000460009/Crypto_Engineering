def ext_gcd(m: int, n: int) -> (int, int, int):  # 拓展欧几里得算法
    """
    input:
        m,n : 要求最大公因数的两个数
    output:
        x,y,gcd(m,n)满足mx+ny=gcd(m,n)
    """
    if (n == 0):                                # 模数为0，最大公因数即为m
        return 1, 0, m
    x0, x1 = 1, 0                               # 初始化参数
    y0, y1 = 0, 1
    r0, r1 = m, n
    while (r1 != 0):
        q = r0 // r1
        r0, r1 = r1, r0 - q * r1                # 辗转相除
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    return x0, y0, r0


def reduce(t: int, r: int, n_inv: int, n: int) -> (int):    # Montgomery转换
    """
    input:
        t : t mod n in Montgomery_mod   # 需要被转换的值
        r : 2^k # 用于代替n的模数
        n_inv : n * n_inv = -1 mod n    # 模数n的逆元的相反数
        n : module  # 模数n

    output:
        REDC(T,R,N',N) = T * R' mod N  (R * R' = 1 mod n)   # Montgomery转换结果，R‘为R的逆元
    """
    if (t < 0 or t > r * n - 1):                # t属于[0,n-1]，否则需要更大的r
        return None

    mod_mask = r - 1                            # 模r取余数对应的二进制掩码，例如模8(1000)的掩码是(111)
    m = ((t & mod_mask) * n_inv) & mod_mask     # m = ((T mod R)N') mod R 取模被转化成与操作

    bitlen_r = r.bit_length() - 1               # 除8(1000)等于向右移3位
    t = (t + m * n) >> bitlen_r                 # (T+mN)/R 除法被转化成移位操作

    if (t < n):
        res = t
    else:
        res = t - n

    if (res < 0 or res > n):                    # 转换后结果还在n的剩余系中
        return None
    else:
        return res


def Montgomery_mul_mod(a: int, b: int, n: int) -> (int):    # Montgomery模乘算法
    """
    input:
            Integer a,b
            module n
            注： 实际上下面的 r2 = r * r mod n 、n的逆元的相反数n_inv都可以进行预计算，后续计算其它模n乘法则无需再算，
            这里为了说明算法每次运行函数时都重算，实际上这样做不会提升效率，因为计算r * r mod n的复杂度实际上与计算a*b mod n复杂度相同，
            因此实际使用或者测试性能时应预计算二者后作为参数传入此函数而不是在函数内部计算。
    output:
            a*b mod n
    """
    bit_len = max(a.bit_length(), b.bit_length(), n.bit_length())   # 转换后的模数应为a、b和n三者中最大的，也可以直接用n的二进制长度
    exp_len = (bit_len + 7) // 8 * 8                                # 新模数的二进制位数

    r = 2 << exp_len     # r = 2 ** exp_len作为新模数
    r2 = r * r % n       # 虽然也是一个模乘，但由于在模数n确定后，bit_len也确定了。因此r也被确定，
                         # 实际上这个值可以进行预计算，这样在后续计算模n的乘法时无需再次计算，速度会大大提升
    x, y, g = ext_gcd(r, n)     # 计算模n的逆元

    if(g!=1):           # 由于r一定为偶数(2^k)，而n一定是奇数(素数)，因此二者一定互素
        return None

    n_inv = (-y) % r    # n的逆元的相反数

    aR = reduce(a * r2, r, n_inv, n)    # aR = a * r2 * r^(-1) mod n = a*r^2*r(-1) mod n = a*r mod n
    bR = reduce(b * r2, r, n_inv, n)    # bR = b * r2 * r^(-1) mod n = b*r^2*r(-1) mod n = b*r mod n
    abR = reduce(aR * bR, r, n_inv, n)  # abR = aR*bR * r^(-1) mod n = ab*r^2*r(-1) mod n = ab*r mod n
    return reduce(abR, r, n_inv, n)     # ab = abR * r^(-1) mod n = ab*r*r(-1) mod n = ab mod n


def Montgomery_mod(a: int, n: int) -> (int):    # Montgomery算法取余
    """
    input:
            Integer a
            module n
            注：与 Montgomery_mul_mod 中相同，此处的 r1 = r mod n和 n的逆元的相反数n_inv都可以进行预计算
    output:
            a mod n in Montgomery_mod
    """

    bit_len = max(a.bit_length(), n.bit_length())   # 转换后的新模式应为a、n中最大的，也可以直接用n的二进制长度
    exp_len = (bit_len + 7) // 8 * 8    # 新模数的二进制位数

    r = 2 << exp_len                    # r = 2 ** exp_len作为新模数
    r1 = r % n                          # 虽然是对n取模，但是可以预计算

    x, y, g = ext_gcd(r, n)             # 计算模n的逆元

    if(g!=1):                           # 由于r一定为偶数(2^k)，而n一定是奇数(素数)，因此二者一定互素
        return None

    n_inv = (-y) % r                    # n的逆元的相反数

    return reduce(a * r1, r, n_inv, n)  # a mod n = a * r1 * r^(-1) mod n = a*r*r(-1) mod n = a mod n


if __name__ == "__main__":

    a = 16828577819077522796756773732363144874763067289554073265911880851248750900710531258850113691509275521227558591520711279834257956614535053543190657402198830092726771884235145167617890369833730056663851311465262189650155334943083791803549476764734691334060030311637343039365775438862010509444000091538982511570036705748698691642637125992291430187606545868499808306654693064106056259222151067438139351891927768869295619956694732045133958296999508259616405123192866414334349875720668312656522706609873110861226818573126260893591165322369247921416947613133618340234442898459802346740329188441360544632762853593353603677184
    b = 23019565722233503926948570794979891498190755526235700903723557111519802770836605868109492193582073533353297286075851909072158888682414466670807803599441287268722185204701327972970631630187104244123932171368899618476721244004287156044751338897018829481766400330136463057302384619879239081434403495655152578260430533418121007244039564444817667850375727032236534872842414978371040740406569679194428609969744781433294636600340522254082811525733091162606040421737715369835295500417159502596097214702859314929451572934710220987226897408444890409028575644481439324777303423834518058717072006558411971189568810970316545950720
    n = 16922126730318846977919802859851367110341966968227944668904301150307620271433351639332780462677576716268997367961148365702751554051884939487413254587023544523046209249128423159308060594845937848101211064212447817794088448789682466565938452242209718662030028438356792630869934753084723059460204083254089803916648150579224884473689565634469362271918899873569880154456428616034079381505469747745685172412417731132281008524591497784646697880755043533708118927731493237045509886664261081311091523861741238569012119653259815516224671494166221186329218574456908728582527827266050317711522356670922429252266558590331850859527

    print(f"a长度:{a.bit_length()}bit\nb长度:{b.bit_length()}bit\nn:长度{n.bit_length()}bit")

    res = Montgomery_mul_mod(a, b, n)
    if (res == a * b % n):
        print(f"模乘结果正确，结果为:\n{res}")
    else:
        print("结果错误")

    res = Montgomery_mod(a, n)
    if (res == a % n):
        print(f"取余结果正确，结果为:\n{res}")
    else:
        print("结果错误")

