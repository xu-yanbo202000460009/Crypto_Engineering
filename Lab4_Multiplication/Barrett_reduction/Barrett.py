
class Barrett_ctx:
    def __init__(self,k:int,mod_mask:int,mu:int):
        self.k=k
        self.mod_mask=mod_mask
        self.mu=mu


def Barrett(ctx:Barrett_ctx, x: int, m: int) -> (int):
    """
    input:
        x           : 需要取模的值
        m           : 模数 m
        ctx.k           : 模数二进制位数
        ctx.mod_mask    : 取模所用的掩码，即 pow(2, k + 1) - 1
        ctx.mu          : pow(2, 2 * k) // m
        注 : 第一个参数中的均为预计算值
    output:
        x mod m
    """

    q1 = x >> (ctx.k - 1)               # x / 2^(k-1)
    q2 = q1 * ctx.mu
    q3 = q2 >> (ctx.k + 1)              # q2 / 2^(k+1)

    r1 = x & ctx.mod_mask               # x % 2^k
    r2 = (q3 * m) & ctx.mod_mask        # q3*m % 2^k
    r = r1 - r2

    if(r<0):
        r+= ctx.mod_mask + 1            # + 2^(k+1)
    while(r >= m):
        r -= m

    return r


if __name__=="__main__":

    a = 16434158026442893356207786848010883666760807899955149673742071143797608301475128182470814151864526876198787687031944609213142535756381888225772126369334795012428488168198383952751846064290752008460792296352795107080229819280355265433153785903061222005917998351208342811880640077013682138128906339393537608955113970457713566057262818351847099792584517449706844049467473695416070565646631901795057960831960711786421503863959699262826131149413582284781645628118033607748388550508465149078635455673704209825416815012818614153897622385126218673258737903450799160385198143027150729238602723087266156867932474212259378591838
    b = 22480044650618656178660713666972550291201909693589551663792536241718557393395122918075675970294993684915329380933449129953280164728920377608210745702579382098361508988966140598604132451354593988402277511102441033668673089847936675824952479391619950665787500322398889704396859980350819415463284663725734939707451692791133796136757387153142253760132545929918491086760170877315469473053290702338309189423578888118451793555020041263752745630598721838482461349353237665854780762126132326754001186233261049735792551694052950182838767000434463290066968402813905590602835374838396541715890631404699190614813291963199751905865
    n = 16525514385076999001874807480323600693693327117410102215726856592097285421321632460285918420583571011981442742149558950881593314503793886218177006432640180198287313719851975741511777924654236179786338929894968572064539500771174283755799269767782928380888699646832805303583920657309299862754105550052822074137351709550024301243837466439911486593670800657783086088336356070345780646001435300532895676184001690558868172387296384555319040899174847200886834890362786364302255748695567462217862816271231678290050898098886538590063155756021700377274627514118074930256374831314502263390158551436447684816666561123370948105644

    print(f"a长度:{a.bit_length()}bit\nb长度:{b.bit_length()}bit\nn:长度{n.bit_length()}bit")

    # 预计算，此处假设是2048位乘法，a、b和m均为2048位
    k = 2048
    new_mod = 1 << k                        # 2^k
    mod_mask = (new_mod<<1) - 1             # 用于取模的掩码值，pow(2, k + 1) - 1
    mu = new_mod**2 // n                    # pow(2, 2 * k) // m
    ctx = Barrett_ctx(k,mod_mask,mu)

    # 使用预计算值计算a*b mod m
    res = Barrett(ctx, a*b, n)
    if (res == a * b % n):
        print(f"模乘结果正确，结果为:\n{res}")
    else:
        print("结果错误")